{"ast":null,"code":"/*\n MIT License http://www.opensource.org/licenses/mit-license.php\n Author Tobias Koppers @sokra\n */\n\"use strict\";\n\nconst _require = require(\"tapable\"),\n      Tapable = _require.Tapable,\n      HookMap = _require.HookMap,\n      SyncHook = _require.SyncHook,\n      SyncWaterfallHook = _require.SyncWaterfallHook;\n\nconst Factory = require(\"enhanced-resolve\").ResolverFactory;\n/** @typedef {import(\"enhanced-resolve\").Resolver} Resolver */\n\n\nmodule.exports = class ResolverFactory extends Tapable {\n  constructor() {\n    super();\n    this.hooks = {\n      resolveOptions: new HookMap(() => new SyncWaterfallHook([\"resolveOptions\"])),\n      resolver: new HookMap(() => new SyncHook([\"resolver\", \"resolveOptions\"]))\n    };\n\n    this._pluginCompat.tap(\"ResolverFactory\", options => {\n      let match;\n      match = /^resolve-options (.+)$/.exec(options.name);\n\n      if (match) {\n        this.hooks.resolveOptions.tap(match[1], options.fn.name || \"unnamed compat plugin\", options.fn);\n        return true;\n      }\n\n      match = /^resolver (.+)$/.exec(options.name);\n\n      if (match) {\n        this.hooks.resolver.tap(match[1], options.fn.name || \"unnamed compat plugin\", options.fn);\n        return true;\n      }\n    });\n\n    this.cache1 = new WeakMap();\n    this.cache2 = new Map();\n  }\n\n  get(type, resolveOptions) {\n    const cachedResolver = this.cache1.get(resolveOptions);\n    if (cachedResolver) return cachedResolver();\n    const ident = \"\".concat(type, \"|\").concat(JSON.stringify(resolveOptions));\n    const resolver = this.cache2.get(ident);\n    if (resolver) return resolver;\n\n    const newResolver = this._create(type, resolveOptions);\n\n    this.cache2.set(ident, newResolver);\n    return newResolver;\n  }\n\n  _create(type, resolveOptions) {\n    const originalResolveOptions = Object.assign({}, resolveOptions);\n    resolveOptions = this.hooks.resolveOptions.for(type).call(resolveOptions);\n    const resolver = Factory.createResolver(resolveOptions);\n\n    if (!resolver) {\n      throw new Error(\"No resolver created\");\n    }\n    /** @type {Map<Object, Resolver>} */\n\n\n    const childCache = new Map();\n\n    resolver.withOptions = options => {\n      const cacheEntry = childCache.get(options);\n      if (cacheEntry !== undefined) return cacheEntry;\n      const mergedOptions = Object.assign({}, originalResolveOptions, options);\n      const resolver = this.get(type, mergedOptions);\n      childCache.set(options, resolver);\n      return resolver;\n    };\n\n    this.hooks.resolver.for(type).call(resolver, resolveOptions);\n    return resolver;\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}